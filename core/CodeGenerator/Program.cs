using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Akka.Interfaced;
using CommandLine;
using CodeWriter;

namespace CodeGen
{
    internal class Program
    {
        private static int Main(string[] args)
        {
            // Parse command line options

            if (args.Length == 1 && args[0].StartsWith("@"))
            {
                var argFile = args[0].Substring(1);
                if (File.Exists(argFile))
                {
                    args = File.ReadAllLines(argFile);
                }
                else
                {
                    Console.WriteLine("File not found: " + argFile);
                    return 1;
                }
            }

            var parser = new Parser(config => config.HelpWriter = Console.Out);
            if (args.Length == 0)
            {
                parser.ParseArguments<Options>(new[] { "--help" });
                return 1;
            }

            Options options = null;
            var result = parser.ParseArguments<Options>(args)
                .WithParsed(r => { options = r; });

            // Run process !

            if (options != null)
                return Process(options);
            else
                return 1;
        }

        private static int Process(Options options)
        {
            try
            {
                Console.WriteLine("Start Process!");

                // Resolve options

                var basePath = Path.GetFullPath(options.Path ?? ".");
                var sources = options.Sources.Where(p => string.IsNullOrWhiteSpace(p) == false && FilterSource(options, p)).Select(p => MakeFullPath(p, basePath)).ToArray();
                var references = options.References.Where(p => string.IsNullOrWhiteSpace(p) == false).Select(p => MakeFullPath(p, basePath)).ToArray();
                var targetDefaultPath = options.UseSlimClient
                    ? @".\Properties\Akka.Interfaced.CodeGen.Slim.cs"
                    : @".\Properties\Akka.Interfaced.CodeGen.cs";
                var targetPath = MakeFullPath(options.TargetFile ?? targetDefaultPath, basePath);

                // Build source and load assembly

                Console.WriteLine("- Build sources");

                var assembly = AssemblyLoader.BuildAndLoad(sources, references, options.Defines.ToArray());
                if (assembly == null)
                    return 1;

                // Generate code

                Console.WriteLine("- Generate code");

                var settings = new CodeWriterSettings(CodeWriterSettings.CSharpDefault);
                settings.TranslationMapping["`"] = "\"";

                var w = new CodeWriter.CodeWriter(settings);
                w.HeadLines = new List<string>()
                {
                    "// ------------------------------------------------------------------------------",
                    "// <auto-generated>",
                    "//     This code was generated by Akka.Interfaced CodeGenerator.",
                    "//",
                    "//     Changes to this file may cause incorrect behavior and will be lost if",
                    "//     the code is regenerated.",
                    "// </auto-generated>",
                    "// ------------------------------------------------------------------------------",
                    "",
                    "using System;",
                    "using System.Threading.Tasks;",
                    "using Akka.Interfaced;",
                };

                if (options.UseSlimClient == false)
                    w.HeadLines.Add("using Akka.Actor;");

                if (options.UseProtobuf)
                {
                    w.HeadLines.Add("using ProtoBuf;");
                    w.HeadLines.Add("using TypeAlias;");
                    w.HeadLines.Add("using System.ComponentModel;");
                }

                w.HeadLines.Add("");

                var actorTypes = GetTypesSafely(assembly).OrderBy(t => t.FullName).Where(t => Utility.IsActorInterface(t)).ToArray();
                var observerTypes = GetTypesSafely(assembly).OrderBy(t => t.FullName).Where(t => Utility.IsObserverInterface(t)).ToArray();

                var actorCodeGen = new InterfacedActorCodeGenerator() { Options = options };
                foreach (var type in actorTypes)
                    actorCodeGen.GenerateCode(type, w);

                var observerCodeGen = new InterfacedObserverCodeGenerator() { Options = options };
                foreach (var type in observerTypes)
                    observerCodeGen.GenerateCode(type, w);

                // Save generated code

                Console.WriteLine("- Save code");

                if (w.WriteAllText(targetPath, true) == false)
                    Console.WriteLine("Nothing changed. Skip writing.");

                return 0;
            }
            catch (Exception e)
            {
                Console.WriteLine("Exception in processing:\n" + e);
                return 1;
            }
        }

        private static IEnumerable<Type> GetTypesSafely(Assembly assembly)
        {
            try
            {
                return assembly.GetTypes();
            }
            catch (ReflectionTypeLoadException ex)
            {
                Console.WriteLine($"GetTypesSafely({assembly.GetName()}) got ReflectionTypeLoadException");
                return ex.Types.Where(x => x != null);
            }
        }

        private static bool FilterSource(Options options, string path)
        {
            if (path.ToLower().IndexOf("akka.interfaced.codegen") != -1)
                return false;

            foreach (var exclude in options.Excludes)
            {
                if (Regex.IsMatch(path, exclude, RegexOptions.IgnoreCase))
                    return false;
            }

            if (options.Includes.Any())
            {
                foreach (var include in options.Includes)
                {
                    if (Regex.IsMatch(path, include, RegexOptions.IgnoreCase))
                        return true;
                }
                return false;
            }

            return true;
        }

        private static string MakeFullPath(string path, string basePath)
        {
            if (Path.IsPathRooted(path))
                return path;
            else
                return Path.Combine(basePath, path);
        }
    }
}
